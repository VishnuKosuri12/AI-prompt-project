AWSTemplateFormatVersion: '2010-09-09'
Description: >-
  Initial environment setup for ChemTrack application â€“
  creating secrets, parameter store, S3 buckets, ECR repos, and SSL cert.

Parameters:
  AppName:
    Type: String
    Default: chemtrack
    Description: Application name prefix
    MinLength: 3
    MaxLength: 20

  CertificateCatalogVersion:
    Type: String
    Description: Version of the SSL certificate catalog product
    MinLength: 1

Resources:

  # API key in SSM
  ChemtrackApiKey:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${AppName}/api-key"
      Description: API key for ChemTrack backend
      Type: String
      Tier: Standard
      Value: !Select [0, !Split ["-", !Ref AWS::StackId]]
      Tags:
        - Key: Name
          Value: !Sub "${AppName}-api-key"

  # Secrets Manager entries
  ChemtrackDbAdminUser:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "${AppName}-db-admin"
      Description: Admin credentials
      GenerateSecretString:
        SecretStringTemplate: '{"username": "postgre"}'
        GenerateStringKey: password
        PasswordLength: 16
        ExcludeCharacters: '"@/\\'

  ChemtrackDbAppUser:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "${AppName}-db-app"
      Description: App user credentials
      GenerateSecretString:
        SecretStringTemplate: '{"username": "chemuser"}'
        GenerateStringKey: password
        PasswordLength: 16
        ExcludeCharacters: '"@/\\'

  ChemtrackEnvVars:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub "${AppName}-env-vars"
      Description: App environment variables
      SecretString: !Sub |
        {"app_url": "${AppName}.${AWS::AccountId}.aws.glpoly.net",
         "db_url": "ctrds.${AWS::AccountId}.aws.glpoly.net"}

  # Reuseable macro for defining ECR repos
  ECRRepos:
    Type: AWS::CloudFormation::Macro  # illustration only, use Mappings/Modules in real usage

  # Sample: main repository
  ChemtrackMainRepo:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub "${AppName}/main"
      ImageScanningConfiguration: { ScanOnPush: true }
      EncryptionConfiguration: { EncryptionType: AES256 }
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules":[{"rulePriority":1,"description":"retain 5 images","selection":{"tagStatus":"any","countType":"imageCountMoreThan","countNumber":5},"action":{"type":"expire"}}]
          }

  # ... define other ECR repositories similarly, possibly via loops in CDK or modules ...

  # S3 buckets
  ProjectBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AppName}-project-bucket-${AWS::AccountId}"
      AccessControl: Private
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Suspended
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault: { SSEAlgorithm: AES256 }

  ProjectBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ProjectBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: DenyInsecureTransport
            Effect: Deny
            Principal: '*'
            Action: 's3:*'
            Resource:
              - !GetAtt ProjectBucket.Arn
              - !Sub "${ProjectBucket.Arn}/*"
            Condition:
              Bool: { aws:SecureTransport: false }

  AccessLogsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AppName}-access-logs-${AWS::AccountId}"
      AccessControl: Private
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Suspended
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault
